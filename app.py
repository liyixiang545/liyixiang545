from flask import (    # request,    # url_for,    # redirect,    Response,    # session,    # render_template,    # make_response,    # g,    # jsonify,)from apps import create_appfrom blueprints.comment_list import bp as comment_bp  # 导入蓝图模板from blueprints.user_list import bp as user_bp  # 导入蓝图模板from blueprints.source_list import bp as source_bp  # 导入蓝图模板# 使用flask创建一个app对象并传递__name__参数app = create_app()# 通过app绑定到/组装/注册蓝图app.register_blueprint(comment_bp)app.register_blueprint(user_bp)app.register_blueprint(source_bp)# #配置数据库与app联动# app.config['SQLALCHEMY_DATABASE_URI'] = DB_URI# app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True# app.config['SECRET_KEY'] = "123456"# @app.before_request# def before_request():#     user_id = session.get('user_id')#     if user_id:#         try:#             user = UserModel.query.get(user_id)#             # 给g绑定一个user变量的值#             # setattr(g,"user",user)#             # 全局变量g#             g.user = user#         except:#             g.user = None# 请求来了->before_request->视图函数->视图函数中返回模板->context_processor# 上下文处理器 渲染所有模板都会执行这个# @app.context_processor# def context_processor():#     if hasattr(g, "user"):#         print(g.user.username)#         return {"user": g.user}#     else:#         return {}# # 创建资源表# class SourceModel(db.Model):#     __tablename__ = 'source'#     id = db.Column(db.Integer,primary_key=True,autoincrement=True)#     source_title = db.Column(db.String(100),nullable=True)#     source_img = db.Column(db.String(400),nullable=True)#     source_msg = db.Column(db.Text,nullable=True)#     create_time = db.Column(db.TIMESTAMP,nullable=True,default='CURRENT_TIMESTAMP')#     update_time = db.Column(db.TIME,nullable=True)#     status = db.Column(db.Integer,nullable=True)## #模型 user# class UserModel(db.Model):#     __tablename__ = 'user'#     id = db.Column(db.Integer, primary_key=True, autoincrement=True)#     username = db.Column(db.String(200),nullable=True)#     password = db.Column(db.String(200),nullable=True)#     email = db.Column(db.String(100),nullable=False,unique=True)#     create_time = db.Column(db.TIMESTAMP,default='CURRENT_TIMESTAMP')#     updata_time = db.Column(db.TIMESTAMP, default='CURRENT_TIMESTAMP')#     status = db.Column(db.Integer,nullable=True)#     img = db.Column(db.String(200),nullable=True)#     def __init__(self,username,password,email,create_time,updata_time,status,img):#         # self.id =id#         self.email=email#         self.img=img#         self.username=username#         self.password=password#         self.create_time = create_time#         self.updata_time = updata_time#         self.status = status## #创建数据库中的表(评论表)# class CommentModel(db.Model):#     __tablename__='comment'#     id = db.Column(db.Integer,primary_key=True,autoincrement=True)#     title = db.Column(db.String(200),nullable=True)#     content = db.Column(db.Text,nullable=True)#     status = db.Column(db.Integer,nullable=True)#     create_time = db.Column(db.DateTime,nullable=True)#     update_time = db.Column(db.DateTime, nullable=True)#     comment_level  = db.Column(db.Integer,nullable=True)#     comment_contact = db.Column(db.String(100),nullable=True)#     #外键/不推荐直接在ORM使用#     Comment_id = db.Column(db.Integer,db.ForeignKey('user.id'))#db.Foreignkey("表名.字段")表名字#     #backref:代表反向引用 代表对方访问我的字段名称 后面需要是复数 加s#     usercomment = db.relationship("UserModel",backref="usercomments")#设置外键后进行绑定#     #usercomment = db.relationship("模板方法名",backref="一对多usercomments")##     def __init__(self,title,content,Comment_id,status,create_time,update_time,comment_level):#         self.Comment_id=Comment_id#         self.status = status#         self.create_time = create_time#         self.update_time = update_time#         self.comment_level = comment_level#         # self.id=id#         self.title=title#         self.content=content## class CatureModel(db.Model):#     __tablename__ = 'cature'#     id = db.Column(db.Integer, primary_key=True, autoincrement=True)#     cature_code = db.Column(db.Integer,nullable=True)#     cature_hash = db.Column(db.Text,nullable=False)# ## # db.drop_all()# db.create_all()# 设置cookie值@app.route("/set_cookie")def set_cookit():    res = Response("cookie 设置")    res.set_cookie("user_id", "xxx", 100)  # 键值对 和过期时间    return res# # 获取cookie值# @app.route("/get_cookie")# def get_cookit():#     user_id = request.cookies.get("user_id")#     print("user_id:", user_id)#     return "获取cookid"### # 设置session 把数据加密 再用session_id作为key， 存放在cookie中# @app.route("/set_session")# def set_session():#     session['user_id'] = "登录重要信息"#     return "设置session成功"### # 获取session值并解析# @app.route("/get_session")# def get_session():#     user_id = session.get("user_id")#     print(user_id)#     return "获取session值"# 请求前 设置全局变量g 获取user_id的值 再去数据库绑定user 再用g取获取用户名# 请求来后对请求头设置# @app.after_request# def apply_caching(response):#     response.headers.add('Access-Control-Allow-Origin','http://127.0.0.1:5000')#带cookie的话，不能写*#     response.headers.add("Access-Control-Allow-Credentials", 'true') # 允许带cookie#     # 这里不能使用add方法，否则会出现 The 'Access-Control-Allow-Origin' header contains multiple values 的问题#     # response.headers['Access-Control-Allow-Origin'] = '*',#     return response@app.route('/')def index_lywz():    return 'hello world'    # 返回一个json格式数据 return {"books": '知道'}# 添加数据 insert tabble comment values(xx)    # user = UserModel(username="abc",password="123213213",email="1370586826@qq.com")    # comment = CommentModel(title="好看吗？",content="xxx")    # db.session.add(user)    # db.session.add(comment)    # #提交操作    # db.session.commit()    # 查询数据 query.filter_by    # comment = Comment.query.filter_by(id=1)[0]    # print(comment.title)    # db.session.commit()    # 修改数据    # comment = Comment.query.filter_by(id=1)[0]    # comment.content = '你好啊'    # db.session.commit()    # 删除数据    # Comment.query.filter_by(id=1).delete()    # db.session.commit()if __name__ == '__main__':    app.run()